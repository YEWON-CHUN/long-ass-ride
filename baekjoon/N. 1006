#초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 
#원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)
#초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 
#특수소대를 아래 조건에 따라 침투 시킬 수 있다.
#한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 
#즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.
#특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.
#한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 W 보다 작거나 같아야 한다.
#이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.


from operator import itemgetter

T = int(input())
for x in range(T):
    N, W = map(int, input().split())
    n1 = list(map(int, input().split()))
    n2 = list(map(int, input().split()))

    n1n2 = []  # 가장 먼저 두개를 묶어서 100이하이면서 + 100과 가장 가까운 조합 만들어서 list에 넣기.
    for i in range(len(n1)):
        # 먼저, n1+n2으로 만들 수 있는 조합
        for j in range(len(n2)):
            if (n1[i] + n2[j] <= W) and (i == j):
                n1n2_2 = list([])
                n1n2_2.append(i + 1)
                n1n2_2.append(j + N + 1)
                n1n2_2.append(n1[i]+n2[j])
                n1n2.append(n1n2_2)

    n1n1 = []  # n1의 인접한 두 구역을 묶어서 100이하이면서 + 100가 가장 가까운 조합 만들어서 list에 넣기.
    for i in range(len(n1)-1):
        if n1[i] + n1[i+1] <= W:
            n1n1_2 = list([])
            n1n1_2.append(i + 1)
            n1n1_2.append(i + 2)
            n1n1_2.append(n1[i] + n1[i+1])
            n1n1.append(n1n1_2)

    if n1[len(n1)-1]+n1[0] <= W:
        n1n1_2 = list([])
        n1n1_2.append(len(n1))
        n1n1_2.append(1)
        n1n1_2.append(n1[len(n1)-1] + n1[0])
        n1n1.append(n1n1_2)


    n2n2 = []  # n2의 인접한 두 구역을 묶어서 100이하이면서 + 100가 가장 가까운 조합 만들어서 list에 넣기.
    for i in range(len(n2)-1):
        if n2[i]+n2[i+1] <= W:
            n2n2_2 = list([])
            n2n2_2.append(i + N + 1)
            n2n2_2.append(i + N + 1)
            n2n2_2.append(n2[i] + n2[i+1])
            n2n2.append(n2n2_2)

    if n2[len(n2)-1]+n2[0] <= W:
        n2n2_2 = list([])
        n2n2_2.append(len(n2)+N)
        n2n2_2.append(1+N)
        n2n2_2.append(n2[len(n2)-1] + n2[0])
        n2n2.append(n2n2_2)


    totalcase = n1n2+n1n1+n2n2
    totalcase.sort(key=itemgetter(2), reverse = True)

    for h in range(len(totalcase)): # h는 기준이되는 key
        for k in range(h+1,len(totalcase)): #k는 h와 비교해서 삭제될 수 있는 비교대상
            if totalcase[h][0] in totalcase[k][0:2]:
                totalcase[k] = ['@','@','@']
            elif totalcase[h][1] in totalcase[k][0:2]:
                totalcase[k] = ['@','@','@']

    totalcase = list(filter(lambda x : x!=['@','@','@'], totalcase))
    result = 2*N - len(totalcase)
    print(result)
